Return-Path: <linux-cifs+bounces-2163-lists+linux-cifs=lfdr.de@vger.kernel.org>
X-Original-To: lists+linux-cifs@lfdr.de
Delivered-To: lists+linux-cifs@lfdr.de
Received: from sv.mirrors.kernel.org (sv.mirrors.kernel.org [139.178.88.99])
	by mail.lfdr.de (Postfix) with ESMTPS id 9BD8D903CB0
	for <lists+linux-cifs@lfdr.de>; Tue, 11 Jun 2024 15:05:52 +0200 (CEST)
Received: from smtp.subspace.kernel.org (wormhole.subspace.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by sv.mirrors.kernel.org (Postfix) with ESMTPS id 340BF2810B2
	for <lists+linux-cifs@lfdr.de>; Tue, 11 Jun 2024 13:05:51 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 1988D38DD1;
	Tue, 11 Jun 2024 13:05:49 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=kernel.org header.i=@kernel.org header.b="r1mZtuF9"
X-Original-To: linux-cifs@vger.kernel.org
Received: from smtp.kernel.org (aws-us-west-2-korg-mail-1.web.codeaurora.org [10.30.226.201])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id E910D1E49E
	for <linux-cifs@vger.kernel.org>; Tue, 11 Jun 2024 13:05:48 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=10.30.226.201
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1718111149; cv=none; b=lSpoHAwXnDOEmYWGH01I/podSCe3I/IhlGiO+0GohJOueI0OP8QnasygtZR3kFeI7TP+w3hGMplBZ2tM8LQ1FIUkCn0C/+dynkUA3tTeZZHU3oTJon4QZzurBX5dxnnUZL+uyuAGkH9CCDBFLkgXq8GQf2exO0iRl0xj1ceywEk=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1718111149; c=relaxed/simple;
	bh=vrRu6pYiI1CGoGo3OBBdpX5F+uz7cAkY06m1v5lYARM=;
	h=MIME-Version:References:In-Reply-To:From:Date:Message-ID:Subject:
	 To:Cc:Content-Type; b=RpA4s72egmBiv3I/3Z80wRvCYMfLGQJi0g8v46/dGtJ3+c57Nwj9Zf5pGwzZ3PddttcY2p1uru+Gew65mQL7YvBSQAWGmPguZ5BmadWaq+RAy/fsz9a/TO1lbSSVapuONPNnkkLTvq0mREniK+O1pWyfKWXZ9eRku1ivBlnL9zs=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dkim=pass (2048-bit key) header.d=kernel.org header.i=@kernel.org header.b=r1mZtuF9; arc=none smtp.client-ip=10.30.226.201
Received: by smtp.kernel.org (Postfix) with ESMTPSA id 8A148C3277B
	for <linux-cifs@vger.kernel.org>; Tue, 11 Jun 2024 13:05:48 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=k20201202; t=1718111148;
	bh=vrRu6pYiI1CGoGo3OBBdpX5F+uz7cAkY06m1v5lYARM=;
	h=References:In-Reply-To:From:Date:Subject:To:Cc:From;
	b=r1mZtuF9P4nYm7CePV+HKrdL6KuDR6vu/0xiK18ZYjXRd3MVJT4i/oPiQwEJUIrVd
	 7upPZSsWEKjbj9DATcoT8oZrL1WX1mQBflNoYzNB8NLHGbGXmM0vyf/BupByLBfo1c
	 AEAd9/A+ZO5NAE4GSKZaQ7bkMizcvPHBtE2iAQZYFArm7b/HEenvXoOXb9/rD9PIls
	 SleY+JPbjzJKM1MWnmgqAbJiZhNDzLPW0Wsq3JQ0qyZMXUyd169fKw8W77NIPy433y
	 vIxuy9MzcK7En4oGwUAGl0lgEGhSBnaoZ6AO8Svd92P8kDRsmo4j+93ZhkYwUdQkUP
	 XVZcCvc4yOR5w==
Received: by mail-oo1-f51.google.com with SMTP id 006d021491bc7-5bad217c51aso1753152eaf.1
        for <linux-cifs@vger.kernel.org>; Tue, 11 Jun 2024 06:05:48 -0700 (PDT)
X-Gm-Message-State: AOJu0YzAaxzy4yWEHx+ayEI/LiRxl2sxg8iofZfVDa1foCXZQgmaaT+h
	tvEdnZv2bCoGV9o8yah3fLCocsj7kJfnmmbAVAq5YDPkW38+GIB/2ACQxDTSqzA/m7gg/0C68F2
	diULUDUQ8aehT3wmgQhhkPiQ+AkY=
X-Google-Smtp-Source: AGHT+IEubY71L0BUc9AjjHPCBPbDB0PAICxIk5I6qux6yZSfFNis0zY/krYHxrt/8+4f4ZN0PGRsoxPvkF4rzDWhfAU=
X-Received: by 2002:a05:6820:1504:b0:5ba:5af0:b80e with SMTP id
 006d021491bc7-5baae76f2b8mr12018014eaf.7.1718111147673; Tue, 11 Jun 2024
 06:05:47 -0700 (PDT)
Precedence: bulk
X-Mailing-List: linux-cifs@vger.kernel.org
List-Id: <linux-cifs.vger.kernel.org>
List-Subscribe: <mailto:linux-cifs+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-cifs+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
References: <20240610141416.8039-1-linkinjeon@kernel.org> <20240610141416.8039-2-linkinjeon@kernel.org>
 <CAH2r5mu_Lyw=jTUegNHAQwqFhAz1=5RmPfdTrVVviFOAQzWYsw@mail.gmail.com>
In-Reply-To: <CAH2r5mu_Lyw=jTUegNHAQwqFhAz1=5RmPfdTrVVviFOAQzWYsw@mail.gmail.com>
From: Namjae Jeon <linkinjeon@kernel.org>
Date: Tue, 11 Jun 2024 22:05:35 +0900
X-Gmail-Original-Message-ID: <CAKYAXd-0+KB7_spm8Mo59F4ufYWtV6grwE8v-1CPEp=0wT_+3A@mail.gmail.com>
Message-ID: <CAKYAXd-0+KB7_spm8Mo59F4ufYWtV6grwE8v-1CPEp=0wT_+3A@mail.gmail.com>
Subject: Re: [PATCH 2/3] ksmbd: add durable scavenger timer
To: Steve French <smfrench@gmail.com>
Cc: linux-cifs@vger.kernel.org, senozhatsky@chromium.org, tom@talpey.com, 
	atteh.mailbox@gmail.com
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: quoted-printable

2024=EB=85=84 6=EC=9B=94 11=EC=9D=BC (=ED=99=94) =EC=98=A4=EC=A0=84 12:31, =
Steve French <smfrench@gmail.com>=EB=8B=98=EC=9D=B4 =EC=9E=91=EC=84=B1:
>
> Minor compile warning was generated by this:
Okay, I will fix it.
Thanks for your review:)
>
> /home/smfrench/smb3-kernel/fs/smb/server/vfs_cache.c:39:19: warning:
> symbol 'dh_task' was not declared. Should it be static?
> /home/smfrench/smb3-kernel/fs/smb/server/vfs_cache.c:40:19: warning:
> symbol 'dh_wq' was not declared. Should it be static?
>
> On Mon, Jun 10, 2024 at 9:14=E2=80=AFAM Namjae Jeon <linkinjeon@kernel.or=
g> wrote:
> >
> > Launch ksmbd-durable-scavenger kernel thread to scan durable fps that
> > have not been reclaimed by a client within the configured time.
> >
> > Signed-off-by: Namjae Jeon <linkinjeon@kernel.org>
> > ---
> >  fs/smb/server/mgmt/user_session.c |   2 +
> >  fs/smb/server/server.c            |   1 +
> >  fs/smb/server/server.h            |   1 +
> >  fs/smb/server/smb2pdu.c           |   2 +-
> >  fs/smb/server/smb2pdu.h           |   2 +
> >  fs/smb/server/vfs_cache.c         | 165 +++++++++++++++++++++++++++++-
> >  fs/smb/server/vfs_cache.h         |   2 +
> >  7 files changed, 169 insertions(+), 6 deletions(-)
> >
> > diff --git a/fs/smb/server/mgmt/user_session.c b/fs/smb/server/mgmt/use=
r_session.c
> > index aec0a7a12405..162a12685d2c 100644
> > --- a/fs/smb/server/mgmt/user_session.c
> > +++ b/fs/smb/server/mgmt/user_session.c
> > @@ -149,6 +149,7 @@ void ksmbd_session_destroy(struct ksmbd_session *se=
ss)
> >
> >         ksmbd_tree_conn_session_logoff(sess);
> >         ksmbd_destroy_file_table(&sess->file_table);
> > +       ksmbd_launch_ksmbd_durable_scavenger();
> >         ksmbd_session_rpc_clear_list(sess);
> >         free_channel_list(sess);
> >         kfree(sess->Preauth_HashValue);
> > @@ -326,6 +327,7 @@ void destroy_previous_session(struct ksmbd_conn *co=
nn,
> >
> >         ksmbd_destroy_file_table(&prev_sess->file_table);
> >         prev_sess->state =3D SMB2_SESSION_EXPIRED;
> > +       ksmbd_launch_ksmbd_durable_scavenger();
> >  out:
> >         up_write(&conn->session_lock);
> >         up_write(&sessions_table_lock);
> > diff --git a/fs/smb/server/server.c b/fs/smb/server/server.c
> > index c67fbc8d6683..4d24cc105ef6 100644
> > --- a/fs/smb/server/server.c
> > +++ b/fs/smb/server/server.c
> > @@ -377,6 +377,7 @@ static void server_ctrl_handle_reset(struct server_=
ctrl_struct *ctrl)
> >  {
> >         ksmbd_ipc_soft_reset();
> >         ksmbd_conn_transport_destroy();
> > +       ksmbd_stop_durable_scavenger();
> >         server_conf_free();
> >         server_conf_init();
> >         WRITE_ONCE(server_conf.state, SERVER_STATE_STARTING_UP);
> > diff --git a/fs/smb/server/server.h b/fs/smb/server/server.h
> > index db7278181760..4fc529335271 100644
> > --- a/fs/smb/server/server.h
> > +++ b/fs/smb/server/server.h
> > @@ -44,6 +44,7 @@ struct ksmbd_server_config {
> >         unsigned int            max_connections;
> >
> >         char                    *conf[SERVER_CONF_WORK_GROUP + 1];
> > +       struct task_struct      *dh_task;
> >  };
> >
> >  extern struct ksmbd_server_config server_conf;
> > diff --git a/fs/smb/server/smb2pdu.c b/fs/smb/server/smb2pdu.c
> > index b6c5a8ea3887..4fb5070d3dc5 100644
> > --- a/fs/smb/server/smb2pdu.c
> > +++ b/fs/smb/server/smb2pdu.c
> > @@ -3519,7 +3519,7 @@ int smb2_open(struct ksmbd_work *work)
> >                                         SMB2_CREATE_GUID_SIZE);
> >                         if (dh_info.timeout)
> >                                 fp->durable_timeout =3D min(dh_info.tim=
eout,
> > -                                               300000);
> > +                                               DURABLE_HANDLE_MAX_TIME=
OUT);
> >                         else
> >                                 fp->durable_timeout =3D 60;
> >                 }
> > diff --git a/fs/smb/server/smb2pdu.h b/fs/smb/server/smb2pdu.h
> > index 643f5e1cfe35..3be7d5ae65a8 100644
> > --- a/fs/smb/server/smb2pdu.h
> > +++ b/fs/smb/server/smb2pdu.h
> > @@ -72,6 +72,8 @@ struct create_durable_req_v2 {
> >         __u8 CreateGuid[16];
> >  } __packed;
> >
> > +#define DURABLE_HANDLE_MAX_TIMEOUT     300000
> > +
> >  struct create_durable_reconn_req {
> >         struct create_context_hdr ccontext;
> >         __u8   Name[8];
> > diff --git a/fs/smb/server/vfs_cache.c b/fs/smb/server/vfs_cache.c
> > index a6804545db28..882a87f9e3ab 100644
> > --- a/fs/smb/server/vfs_cache.c
> > +++ b/fs/smb/server/vfs_cache.c
> > @@ -8,6 +8,8 @@
> >  #include <linux/filelock.h>
> >  #include <linux/slab.h>
> >  #include <linux/vmalloc.h>
> > +#include <linux/kthread.h>
> > +#include <linux/freezer.h>
> >
> >  #include "glob.h"
> >  #include "vfs_cache.h"
> > @@ -17,6 +19,7 @@
> >  #include "mgmt/tree_connect.h"
> >  #include "mgmt/user_session.h"
> >  #include "smb_common.h"
> > +#include "server.h"
> >
> >  #define S_DEL_PENDING                  1
> >  #define S_DEL_ON_CLS                   2
> > @@ -31,6 +34,11 @@ static struct ksmbd_file_table global_ft;
> >  static atomic_long_t fd_limit;
> >  static struct kmem_cache *filp_cache;
> >
> > +static bool durable_scavenger_running;
> > +static DEFINE_MUTEX(durable_scavenger_lock);
> > +struct task_struc *dh_task;
> > +wait_queue_head_t dh_wq;
> > +
> >  void ksmbd_set_fd_limit(unsigned long limit)
> >  {
> >         limit =3D min(limit, get_max_files());
> > @@ -279,9 +287,16 @@ static void __ksmbd_remove_durable_fd(struct ksmbd=
_file *fp)
> >         if (!has_file_id(fp->persistent_id))
> >                 return;
> >
> > -       write_lock(&global_ft.lock);
> >         idr_remove(global_ft.idr, fp->persistent_id);
> > +}
> > +
> > +static void ksmbd_remove_durable_fd(struct ksmbd_file *fp)
> > +{
> > +       write_lock(&global_ft.lock);
> > +       __ksmbd_remove_durable_fd(fp);
> >         write_unlock(&global_ft.lock);
> > +       if (waitqueue_active(&dh_wq))
> > +               wake_up(&dh_wq);
> >  }
> >
> >  static void __ksmbd_remove_fd(struct ksmbd_file_table *ft, struct ksmb=
d_file *fp)
> > @@ -304,7 +319,7 @@ static void __ksmbd_close_fd(struct ksmbd_file_tabl=
e *ft, struct ksmbd_file *fp)
> >         struct ksmbd_lock *smb_lock, *tmp_lock;
> >
> >         fd_limit_close();
> > -       __ksmbd_remove_durable_fd(fp);
> > +       ksmbd_remove_durable_fd(fp);
> >         if (ft)
> >                 __ksmbd_remove_fd(ft, fp);
> >
> > @@ -696,6 +711,142 @@ static bool tree_conn_fd_check(struct ksmbd_tree_=
connect *tcon,
> >         return fp->tcon !=3D tcon;
> >  }
> >
> > +static bool ksmbd_durable_scavenger_alive(void)
> > +{
> > +       mutex_lock(&durable_scavenger_lock);
> > +       if (!durable_scavenger_running) {
> > +               mutex_unlock(&durable_scavenger_lock);
> > +               return false;
> > +       }
> > +       mutex_unlock(&durable_scavenger_lock);
> > +
> > +       if (kthread_should_stop())
> > +               return false;
> > +
> > +       if (idr_is_empty(global_ft.idr))
> > +               return false;
> > +
> > +       return true;
> > +}
> > +
> > +static void ksmbd_scavenger_dispose_dh(struct list_head *head)
> > +{
> > +       while (!list_empty(head)) {
> > +               struct ksmbd_file *fp;
> > +
> > +               fp =3D list_first_entry(head, struct ksmbd_file, node);
> > +               list_del_init(&fp->node);
> > +               __ksmbd_close_fd(NULL, fp);
> > +       }
> > +}
> > +
> > +static int ksmbd_durable_scavenger(void *dummy)
> > +{
> > +       struct ksmbd_file *fp =3D NULL;
> > +       unsigned int id;
> > +       unsigned int min_timeout =3D 1;
> > +       bool found_fp_timeout;
> > +       LIST_HEAD(scavenger_list);
> > +       unsigned long remaining_jiffies;
> > +
> > +       __module_get(THIS_MODULE);
> > +
> > +       set_freezable();
> > +       while (ksmbd_durable_scavenger_alive()) {
> > +               if (try_to_freeze())
> > +                       continue;
> > +
> > +               found_fp_timeout =3D false;
> > +
> > +               remaining_jiffies =3D wait_event_timeout(dh_wq,
> > +                                  ksmbd_durable_scavenger_alive() =3D=
=3D false,
> > +                                  __msecs_to_jiffies(min_timeout));
> > +               if (remaining_jiffies)
> > +                       min_timeout =3D jiffies_to_msecs(remaining_jiff=
ies);
> > +               else
> > +                       min_timeout =3D DURABLE_HANDLE_MAX_TIMEOUT;
> > +
> > +               write_lock(&global_ft.lock);
> > +               idr_for_each_entry(global_ft.idr, fp, id) {
> > +                       if (!fp->durable_timeout)
> > +                               continue;
> > +
> > +                       if (atomic_read(&fp->refcount) > 1 ||
> > +                           fp->conn)
> > +                               continue;
> > +
> > +                       found_fp_timeout =3D true;
> > +                       if (fp->durable_scavenger_timeout <=3D
> > +                           jiffies_to_msecs(jiffies)) {
> > +                               __ksmbd_remove_durable_fd(fp);
> > +                               list_add(&fp->node, &scavenger_list);
> > +                       } else {
> > +                               unsigned long durable_timeout;
> > +
> > +                               durable_timeout =3D
> > +                                       fp->durable_scavenger_timeout -
> > +                                               jiffies_to_msecs(jiffie=
s);
> > +
> > +                               if (min_timeout > durable_timeout)
> > +                                       min_timeout =3D durable_timeout=
;
> > +                       }
> > +               }
> > +               write_unlock(&global_ft.lock);
> > +
> > +               ksmbd_scavenger_dispose_dh(&scavenger_list);
> > +
> > +               if (found_fp_timeout =3D=3D false)
> > +                       break;
> > +       }
> > +
> > +       mutex_lock(&durable_scavenger_lock);
> > +       durable_scavenger_running =3D false;
> > +       mutex_unlock(&durable_scavenger_lock);
> > +
> > +       module_put(THIS_MODULE);
> > +
> > +       return 0;
> > +}
> > +
> > +void ksmbd_launch_ksmbd_durable_scavenger(void)
> > +{
> > +       if (!(server_conf.flags & KSMBD_GLOBAL_FLAG_DURABLE_HANDLE))
> > +               return;
> > +
> > +       mutex_lock(&durable_scavenger_lock);
> > +       if (durable_scavenger_running =3D=3D true) {
> > +               mutex_unlock(&durable_scavenger_lock);
> > +               return;
> > +       }
> > +
> > +       durable_scavenger_running =3D true;
> > +
> > +       server_conf.dh_task =3D kthread_run(ksmbd_durable_scavenger,
> > +                                    (void *)NULL, "ksmbd-durable-scave=
nger");
> > +       if (IS_ERR(server_conf.dh_task))
> > +               pr_err("cannot start conn thread, err : %ld\n",
> > +                      PTR_ERR(server_conf.dh_task));
> > +       mutex_unlock(&durable_scavenger_lock);
> > +}
> > +
> > +void ksmbd_stop_durable_scavenger(void)
> > +{
> > +       if (!(server_conf.flags & KSMBD_GLOBAL_FLAG_DURABLE_HANDLE))
> > +               return;
> > +
> > +       mutex_lock(&durable_scavenger_lock);
> > +       if (!durable_scavenger_running) {
> > +               mutex_unlock(&durable_scavenger_lock);
> > +               return;
> > +       }
> > +
> > +       durable_scavenger_running =3D false;
> > +       if (waitqueue_active(&dh_wq))
> > +               wake_up(&dh_wq);
> > +       mutex_unlock(&durable_scavenger_lock);
> > +       kthread_stop(server_conf.dh_task);
> > +}
> > +
> >  static bool session_fd_check(struct ksmbd_tree_connect *tcon,
> >                              struct ksmbd_file *fp)
> >  {
> > @@ -756,11 +907,12 @@ void ksmbd_free_global_file_table(void)
> >         unsigned int            id;
> >
> >         idr_for_each_entry(global_ft.idr, fp, id) {
> > -               __ksmbd_remove_durable_fd(fp);
> > -               kmem_cache_free(filp_cache, fp);
> > +               ksmbd_remove_durable_fd(fp);
> > +               __ksmbd_close_fd(NULL, fp);
> >         }
> >
> > -       ksmbd_destroy_file_table(&global_ft);
> > +       idr_destroy(global_ft.idr);
> > +       kfree(global_ft.idr);
> >  }
> >
> >  int ksmbd_validate_name_reconnect(struct ksmbd_share_config *share,
> > @@ -816,6 +968,7 @@ int ksmbd_reopen_durable_fd(struct ksmbd_work *work=
, struct ksmbd_file *fp)
> >         }
> >         up_write(&ci->m_lock);
> >
> > +       fp->f_state =3D FP_NEW;
> >         __open_id(&work->sess->file_table, fp, OPEN_ID_TYPE_VOLATILE_ID=
);
> >         if (!has_file_id(fp->volatile_id)) {
> >                 fp->conn =3D NULL;
> > @@ -855,6 +1008,8 @@ int ksmbd_init_file_cache(void)
> >         if (!filp_cache)
> >                 goto out;
> >
> > +       init_waitqueue_head(&dh_wq);
> > +
> >         return 0;
> >
> >  out:
> > diff --git a/fs/smb/server/vfs_cache.h b/fs/smb/server/vfs_cache.h
> > index f2ab1514e81a..b0f6d0f94cb8 100644
> > --- a/fs/smb/server/vfs_cache.h
> > +++ b/fs/smb/server/vfs_cache.h
> > @@ -153,6 +153,8 @@ struct ksmbd_file *ksmbd_lookup_fd_cguid(char *cgui=
d);
> >  struct ksmbd_file *ksmbd_lookup_fd_inode(struct dentry *dentry);
> >  unsigned int ksmbd_open_durable_fd(struct ksmbd_file *fp);
> >  struct ksmbd_file *ksmbd_open_fd(struct ksmbd_work *work, struct file =
*filp);
> > +void ksmbd_launch_ksmbd_durable_scavenger(void);
> > +void ksmbd_stop_durable_scavenger(void);
> >  void ksmbd_close_tree_conn_fds(struct ksmbd_work *work);
> >  void ksmbd_close_session_fds(struct ksmbd_work *work);
> >  int ksmbd_close_inode_fds(struct ksmbd_work *work, struct inode *inode=
);
> > --
> > 2.25.1
> >
>
>
> --
> Thanks,
>
> Steve

